---
layout: post
title: '算法笔记（第一周）'
subtitle: '算法'
date: 2020-6-21
categories: 技术
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags: jekyll 前端开发 设计
---
题目描述：

给定一个未经排序的整数数组，找到最长且连续的的递增序列。

class Solution {

public int findLengthOfLCIS(int[] nums) {

if(nums.length == 0)

return 0; int max = 0;

int count = 1;

for(int i=0;i<nums.length - 1;i++){

if(nums[i] < nums[i+1]){

count++;

}else{

max = Math.max(count,max);

count = 1; }

}

max = Math.max(count,max);

return max; }}








给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。

你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

示例:


对于这道题，首先想到的就是暴力方法，即使用两个for循环，遍历两次数组，看有没有和是目标值的。显然这样时间复杂度太大，O(n*n)

因此需要改良的算法，用到哈希查找的方法。

建立哈希表，从左向右扫描一遍，将整数与索引存放到map中。扫描一遍，对其中的每一个整数K，搜索 target-K 在map中是否存在即可。若存在，则输出 K 与 target-K 的下标即可。此算法的时间复杂度为O(n)

public int[] twoSum(int[] nums, int target) {   

Map<Integer, Integer> map = new HashMap<>();   

for (int i = 0; i < nums.length; i++) {       

int complement = target - nums[i];       

if (map.containsKey(complement)) {           

return new int[] { map.get(complement), i };       

}       

map.put(nums[i], i);    }   

throw new IllegalArgumentException("No two sum solution");}

转化思想，与其一个个比较数组中的两数之和是否为目标值不如确定一个加数，使用目标值减去其得到另一个加数，看是否在数组中存在。



两数之和

题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

　　　　　你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

　　示例：给定 nums = [2, 7, 11, 15], target = 9，因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]

class Solution { 

public int[] twoSum(int[] nums, int target) {

for(int i = 0; i < nums.length; i++){

for(int j = i + 1; j < nums.length; j++){

if(nums[i] + nums[j] == target){

return new int[] {i, j};

}

 }

 }

 throw new IllegalArgumentException("No two sum solution");

 }  }

该解法的空间复杂度是 O（1），时间复杂度是O（n^2）；

第二种解题思路是借助了哈希表，参考了题解第一次迭代先将数组中所有元素，以及元素所对应的下标存进哈希表中，然后第二次迭代时，依次取出数组中的元素，计算出该元素与目标值target的差值，查看该差值是否在哈希表中，如果存在并且下标不是本次比较的元素（不能重复利用同一个元素），则返回该值和差值所对应的下标。代码如下

class Solution {

public int[] twoSum(int[] nums, int target) { 

Map<Integer, Integer> hashMap = new HashMap();

for(int i = 0; i < nums.length; i++){ 

hashMap.put(nums[i], i);

}

for(int i = 0; i < nums.length; i++){

nt num = target - nums[i]; 

if(hashMap.containsKey(num) && hashMap.get(num) != i){ 

return new int[] {i, hashMap.get(num)};

} 

} 

throw new IllegalArgumentException("no two sum solution");

}

}
